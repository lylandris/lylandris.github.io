# 澄清 P4 和 OpenFlow 之间的区别

有些人问我们 P4 和 OpenFlow 之间有什么区别。是不是 P4 只是 OpenFlow 的另一个版本？在这篇博客中，我们解释了为什么 P4 比 OpenFlow 能够解决更普遍的问题。在 P4 中，OpenFlow 是许多可能的描述转发平面的方案之一。P4 不是像有些人认为的 OpenFlow 2.0。虽然它们都专注于如何开放转发平面，但 P4 致力于解决网络中的不同需求，这个需求就是“编程”数据平面。

回顾 2007 年，当时的 OpenFlow 的最初构想，我们希望找到一种公共的方法来远程控制不同的交换机的方法。我们注意到：在大多数网络中，交换机做几乎同样的事情：以太网交换，IPv4，访问控制列表（ACL），虚拟局域网等。如果我们可以定义一个标准的，开放的接口来填充这些交换机的转发表（即以太网地址查找哈希表中，最长前缀匹配表对IPv4和ACL的通配符查询），那么我们可以创建控制平面用来控制各种不同厂商的交换机。当时的想法是非常简单的（虽然有些供应商害怕了，这将批量商品化交换机产品，并威胁到他们的舒适利润率。也许一定程度上已经做到了）。其主要目标是让网络所有者和运营者可以创建更加简单的控制平面来控制自己的网络。我们可以看见这是卓有成效的，因为当今许多大型数据中心都使用自主研发的控制平面构建网络，利用部分或者全部的数据平面的开放接口。

重点是，OpenFlow 假设交换机有一个固定的，周知的行为，通常描述于交换 ASIC 的 Datasheet 中。传统的高性能交换芯片支持一系列固定的协议，即这些厂商直接在硅芯片上实现的 IEEE 和 IETF 标准协议。你不能改变硅芯片行为，并在此之上添加新的协议，或使用新方法来测量和控制数据通路。（当下，向一个固定功能的 ASIC 中添加一个协议需要差不多四年！）所以，OpenFlow 的第一个版本可以填充表仅适用于四种常见的协议（以太网交换，虚拟局域网，IPv4，访问控制列表）。随着被关注越来越多，越来越多的报文头类型被添加到 OpenFlow 的，如 IPv6， MPLS 和 VXLAN。今天，OpenFlow 的让我们可以添加或删除超过 50 种不同的报文类型的转发表项。交换机厂商可以使用 ONF 定义的 TTP 来告诉控制面其只是哪些报文头。OpenFlow 的并没有真正控制交换机的行为；它只是提供了一种方式来填充周知的转发表。

你可能已经注意到 OpenFlow，并且考虑如果其保持于支持越来越多的报文头格式。这是编程一个很多人担心的问题。这个问题出现是因为 OpenFlow 的是强加给我们的交换芯片的一个相当奇怪的属性的妥协。这是我们所想当然的属性：交换机芯片是不可编程的。如果他们是可编程的，我们就不会需要像 OpenFlow 这样的的一个固定的协议。相反，我们只会告诉交换机如何处理数据包，配置什么表。程序员可以定义任何 API 来填充他们的交换机中创建的表。

那么，为什么交换机芯片是固定功能的？这是一个很好的问题，也是一个网络界的“传统智慧”（或圣牛）之一，从而值得大家时不时重温。 在过去，可编程交换芯片的性能只能百分之一到十分之一于固定功能的ASIC（还记得NPU吗？）。但现如今，市场上可重配置的交换机芯片已经达到和固定功能的交换芯片一样快。我们更进一步的展示如何让可编程交换芯片做到和固定功能交换芯片一样快。我们称这种类型的可编程芯片为“PISA”芯片（协议无关交换体系结构）。如果可编程 PISA芯片和固定功能交换芯片一样地快，那么我们就为网络开创了一个可自行定义报文如何处理的新时代。再进一步，如果我们找到了一个语言来编程快速的交换机芯片，那么我们也可以用这个语言定义 *已经存在的* 慢速的交换机芯片，包括NPU、FPGA或者软件交换机。我们认为：如果我们能找到共同语言到网络中的每台交换机编程，那么交换机之间的互操作性几乎是紧凑的——我们可以编程，他们都以同样的方式。哎呀，我们甚至可以使用相同的语言来形容固定功能的 ASIC 交换过程，而不必依赖于解释用英文写的模棱两可的 Datasheet（例如，解释SHOULD和MAY的标准文档）。

于是在 2013 年，带着这些目标，由 Google, Intel, Microsoft, Stanford, Princeton, and Barefoot 发起的工作组定义了 P4 语言。

![p4-openflow](/images/2016-09-12-clarifying-the-differences-between-p4-and-openflow-p4-openflow.png)

P4 完全改变了网络的这种“自下而上”的模式。相较于交换机告诉我们其有限的支持的能力，P4 为我们提供了一种方式来告诉交换机它应该做什么，以及它应该如何处理数据包。P4 让我们定义报文头供交换机识别、并且告诉交换机这个报文头的匹配方式、以及匹配后的具体行为。例如，我们可以告诉交换机通过对 32 位目的地址执行最长前缀匹配来处理 IPv4 的头，将它发送到下一跳，递减和检查 TTL，更新校验，并在新的以太网封装头。该协议仅仅是在 P4 表示的程序。P4 明确指定了头的匹配精确的方法，并对其执行的操作。事实上，你可以编译 P4 程序直接生成可执行交换机 - 开源编译器已经存在，并允许测试新的交换机功能。许多公司也加入 P4.org 帮助一起移植生态系统。一些已经证明 P4 解决方案，并开始为他们的客户提供工具集。

P4 让我们首先通过描述其转发行为“自上而下”地控制交换机，然后再填充我们再描述中定义的表。进一步地，P4 的编译器通常也可以自动生成用来填充这些表所需的 API。这使得我们可以远离目前的交换机芯片厂商提供的那些固定的、封闭的 API。区别于芯片厂商为我们定义 API 并将我们锁定在其产品线上从而不断等待次世代芯片、P4 允许我们定义我们期望配置表项而需要的 API。这就是我们认为为何 P4 是“自上而下”的，因为其使得网络架构、编程和开发是自主可控，不再掌握在芯片供应商手中。

OpenFlow 在可编程交换机和支持 OpenFlow 协议的固定功能交换机混合组网的时候还是十分有用的。事实上，有一个 P4 程序命名为 `openflow.p4` 将 PISA 芯片编程为支持 OpenFlow。换句话说，在 P4 语言范畴中，OpenFlow 是一个程序。这样 OpenFlow 和 P4 在网络中是可以共同工作的。考虑到 OpenFlow 是为 SDN 网络设计、用来分离控制面和转发面，P4 是设计为可以编程控制任何交换机和路由器的行为——无论是被本地交换机系统所控制、还是远程控制于 SDN 控制器。

暂时还没有特别的因素驱动我们使用 P4 替代 OpenFlow。市场上还有非常多的固定功能交换机芯片，其中相当多的芯片希望继续使用 OpenFlow 来控制。因此，越来越多的 TTP 为固定功能交换机所设计，这支撑了为什么 OpenFlow 还需要留下。P4 提供了一个平滑的方法部署固定功能交换机和可编程交换机的混合网络，并且允许我们将新特性和协议使用软件引入，而不是等待硬件升级换代。同时，P4 允许程序员保留其自己的差异化特性，而不是必须将芯片和系统的功能全部开放共享给其他供应商，特别是竞争对手。
